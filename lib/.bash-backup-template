#!/usr/bin/env bash

# BBT BBS - Better Backup Tool Bash Backup Script
# This script is generated by the Better Backup Tool (BBT),
# and is used to create backup snapshots.

shopt -s extglob

# the resources we want to backup
declare -a backup_resources=(
{{!backup_resources}}
)

# resources which should be excluded from backups
declare -a backup_exclude_resources=(
{{!backup_exclude_resources}}
)

backup_src="{{!backup_src}}"
backup_dest="{{!backup_dest}}"
backup_src_ssh_opts="{{!backup_src_ssh_opts}}"
backup_dest_ssh_opts="{{!backup_dest_ssh_opts}}"
archive_basename="{{!archive_base_name}}"
archive_extension="{{!archive_extension}}"
link_latest="{{!archive_link_latest}}"
ch_archive_owner="{{!archive_owner}}"
ch_archive_perms="{{!archive_perms}}"
archive_keep_last={{!archive_keep_last}}
quiet=false
max_arg_len=`getconf ARG_MAX`

while [ $# -gt 0 ]; do
  case "$1" in
    -q|--quiet)
      quiet=true
      ;;
    -h|--help)
      printf "BBT Backup Help. \n"
      printf "Available Command Arguments: \n"
      printf "\t-q --quiet : Do NOT print status to stdout\n"
      exit 0
      ;;
    *)
      printf "Unknown or invalid command line argument : $1 \n"
      printf "Arguments are in the form -s -s=value or --long --long=value\n"
      printf "Use -h or --help for a full list of arguments"
      exit 1
  esac
  shift
done

# parse_url "ssh://user@host:9090/this/is/the.path"
# echo "Potocol:"$proto" User:"$usr" Host:"$host" Port:"$port" Path:"$path
function parse_url() {
  local url=$1

  tmp=${url#*//};user=${tmp%@*}
  tmp=${url#*@};host=${tmp%%/*};[[ ${url#*://} == *":"* ]] && host=${host%:*}
  tmp=${url#*//};path=/${tmp#*/}
  proto=${url%%:*}
  [[ ${url#*://} == *":"* ]] && tmp=${url##*:} && port=${tmp%%/*}
  # echo "parse_url Proto:"$proto", User:"$user", Host:"$host", Port:"$port", Path:"$path
}

function join_by {
  local d="${1-}" f="${2-}"
  if shift 2; then
    printf "%s" "$f" "${@/#/$d}"
  fi
}

function printerr() {
  printf "%s\n" "$*" >&2
}


function pre_exec() {
  if [[ "$quiet" != true ]]; then
    set -x
  fi
  set -eo pipefail
}

function post_exec() {
  set +x
  set +eo pipefail
}

function chown_remote() {
  local remote_str="$1"
  local remote_file="$2"
  if [[ "${ch_archive_owner}" != "" ]]; then
    if [[ "$quiet" != true ]]; then
      echo "Changing ownership to ${ch_archive_owner} on ${remote_str} ${remote_file}"
    fi
    pre_exec
    ssh ${remote_str} "chown ${ch_archive_owner} ${remote_file}"
    post_exec
  fi
}

function chmod_remote() {
  local remote_str="$1"
  local remote_file="$2"
  if [[ "${ch_archive_perms}" != "" ]]; then
    if [[ "$quiet" != true ]]; then
      echo "Changing permissions to ${ch_archive_perms} on ${remote_str} ${remote_file}"
    fi
    pre_exec
    ssh ${remote_str} "chmod ${ch_archive_perms} ${remote_file}"
    post_exec
  fi
}

function link_latest_remote() {
  local remote_str="$1"
  local remote_file="$2"

  local remote_target_filename=${remote_file##*\/}
  local remote_target_path=${remote_file%\/*}

  if [[ "${link_latest}" == true ]]; then
    if [[ "$quiet" != true ]]; then
      echo "Symlinking ${remote_str} ${remote_file} => ${remote_link}"
    fi
    pre_exec
    ssh ${remote_str} "cd ${remote_target_path} && ln -sf ${remote_target_filename} latest"
    post_exec
  fi
}

function clean_older_than_remote() {
  local remote_str="$1"
  local remote_file="$2"
  local remote_matchname="$3"
  local remote_path="${remote_file%\/*}"
  if [[ "${archive_keep_last}" -gt 0 ]]; then
    if [[ "$quiet" != true ]]; then
      echo "Keeping ${archive_keep_last} most recent snapshots, removing oldest snapshots matching name '${remote_matchname}' from ${remote_str} ${remote_path} .."
    fi

    # we pass this to tail -n +{} which will give us lines starting at that number,
    # so we need one higher to keep the last n
    local tail_num=$(( ${archive_keep_last} + 1 ))

    pre_exec
    # this is one of the more complex command lines..
    # find is searching the remote path, using the wildcard match for the filename (to ensure we only remove snapshots)
    # find will print the last modification time (%T+) along with the filename (%p), separated by a null (\0) and ending in a newline..
    # sort -r will sort the list by modification time newest at the top
    # tail -n + will return only lines AFTER $archive_keep_last, giving us only the oldest files greater than the last $archive_keep_last
    # we then awk -F '\0' to print only the filename
    # and finally pipe that to xargs to reomove it
    # the xargs invocation here is faster, but might not work everywhere..  xargs -I {} rm -- {} should work but be slower.. xargs -d '\n' -r rm --
    ssh ${remote_str} find ${remote_path} -name ${remote_matchname} -printf '%T+\0%p\n' | sort -r | tail -n +${tail_num} | awk -F '\0' '{print $2}' | xargs -I {} rm -- {}
    post_exec
  fi
}

function chmod_local() {
  local local_file="$1"
  if [[ "${ch_archive_perms}" != "" ]]; then
    if [[ "$quiet" != true ]]; then
      echo "Changing permissions to ${ch_archive_perms} on ${local_file}"
    fi
    pre_exec
    chmod ${ch_archive_perms} ${local_file}
    post_exec
  fi
}

function chown_local() {
  local local_file="$1"
  if [[ "${ch_archive_owner}" != "" ]]; then
    if [[ "$quiet" != true ]]; then
      echo "Changing ownership to ${ch_archive_owner} on ${local_file}"
    fi
    pre_exec
    chown ${ch_archive_owner} ${local_file}
    post_exec
  fi
}

function link_latest_local() {
  local local_file="$1"
  local target_filename="${local_file##*\/}"
  local target_path="${local_file%\/*}"
  local local_link="${local_file%\/*}/latest"

  if [[ "${link_latest}" == true ]]; then
    if [[ -e $local_link || -L $local_link ]]; then
      if [[ ! -L $local_link ]]; then
        printerr "latest already exists but is not a symlink, exiting - ${local_link}"
        exit 1;
      else
        # this seems redundant, but ln will still error even with -f,
        # if the new link points to the same file as the old one.
        # instead of detecting that condition, its easier to just remove the link.
        rm ${local_link}
      fi
    fi
    if [[ "$quiet" != true ]]; then
      echo "Linking ${local_link} => ${local_file}"
    fi
    pre_exec
    # ln has an easier time if you just cd to the dir where you want the link..
    # then it is easy to make the relative link.
    local cdir=`pwd`
    cd "${target_path}" && ln -sf "${target_filename}" "latest" && cd "${cdir}"
    post_exec
  fi
}

# This is done in this way so that we don't accidentally remove all old backups..
# we will always keep at least X amount of snapshots.
function clean_older_than_local() {
  local local_file="$1"
  local local_path="${local_file%\/*}"
  local match_name="$2"
  if [[ "${archive_keep_last}" -gt 0 ]]; then
    if [[ "$quiet" != true ]]; then
      echo "Keeping ${archive_keep_last} most recent snapshots, removing anything older matching name '${match_name}' from ${local_path} .."
    fi
    # this is one of the more complex command lines..
    # find is searching the path, using the wildcard match for the filename (to ensure we only remove snapshots taken by this script)
    # find will print the last modification time (%T+) along with the filename (%p), separated by a null (\0) and ending in a newline..
    # sort -r will sort the list by modification time newest at the top
    # tail -n + will return only lines AFTER $archive_keep_last, giving us only the oldest files greater than the last $archive_keep_last
    # we then awk -F '\0' to print only the filename
    # and finally pipe that to xargs to reomove it
    # the xargs invocation here is faster, but might not work everywhere..  xargs -I {} rm -- {} should work but be slower..

    # to make this more complicated, find complains sometimes when it is not in a directory you have permissions to fchdir into?
    # so we get around that by making sure we are in tmp before running it..
    # .. unit tests use relative paths, which fail when switching the dir..
    # so we only use this is we can not -x in pwd (as that is the case find complains about?)
    local original_dir=$(pwd)
    if [ ! -x ${original_dir} ]; then
      cd /tmp
    fi

    # we pass this to tail -n +{} which will give us lines starting at that number,
    # so we need one higher to keep the last n
    local tail_num=$(( ${archive_keep_last} + 1 ))

    pre_exec
    find ${local_path} -name ${match_name} -printf '%T+\0%p\n' | sort -r | tail -n +${tail_num} | awk -F '\0' '{print $2}' | xargs -I {} rm -- {}
    post_exec
    cd $original_dir
  fi
}

# we replace any leading / with ./ because that is what tar expects.
# this is intentional, this is the kind of detail BBT makes easier.
# just put filenames in the array, and let BBT do the right thing.
backup_resource_str=`join_by " " ${backup_resources[@]/#\//.\/}`
# exclude resource names need to match the resource name, so we also replace the leading / with ./
exclude_resource_str=`join_by " --exclude " "${backup_exclude_resources[@]/#\//.\/}"`
if [[ "${exclude_resource_str}" != "" ]]; then
  exclude_resource_str="--anchored --exclude ${exclude_resource_str} "
fi
backup_str_len=${#backup_resource_str}
exclude_str_len=${#exclude_resource_str}
command_len_estimate=50
estimated_length=$(( ${backup_str_len} + ${exclude_str_len} + ${command_len_estimate} ))
if [ ${estimated_length} -ge ${max_arg_len} ]; then
  # this is just to handle an edge case..
  # a future resolution for this is to write the list of resources to a file,
  # and use the various options to tar instead.. (eg tar -cf - --verbatim-files-from --files-from tmpfile.txt)
  # for now we just error out before something bad happens.
  printf "Whoops.. Sorry, you hit an edge case.\n"
  printf "The the length of the command line generated for you backup exceeds the maximum length of command line arguments.\n"
  printf "Your Command Line: ${command_len_estimate} >=  Maximum Length: ${max_arg_len}\n"
  printf "Please file a bug, and in the meantime you can try to split your backup resources into multiple scripts?\n"
  exit 1;
fi

if [[ "$quiet" != true ]]; then
  start_time=`date`
  printf "$0 run started.\nStart Time: ${start_time}\n"
fi

archive_datetime=`date "+%F-%H_%M_%S"`
archive_filename="${archive_basename}-${archive_datetime}${archive_extension}"
archive_matchname="${archive_basename}-*${archive_extension}"

ssh_prefix="ssh://"

if [[ "$quiet" != true ]]; then
  echo "Trying backup src: ${backup_src}, dest: ${backup_dest}"
fi

# if the backup source is remote..
if [[ "$backup_src" == "${ssh_prefix}"* ]]; then

  parse_url "$backup_src"
  backup_src_uri="ssh://${user}@${host}"
  if [[ "$port" != "" ]]; then
    backup_src_ssh_opts="-p ${port} ${backup_src_ssh_opts}"
  fi
  backup_src_path="${path}"

  # if the backup destination is remote..
  if [[ "$backup_dest" == "${ssh_prefix}"* ]]; then

    parse_url "$backup_dest"
    backup_dest_uri="ssh://${user}@${host}"
    if [[ "$port" != "" ]]; then
      backup_dest_ssh_opts="-p ${port} ${backup_dest_ssh_opts}"
    fi
    backup_dest_path="${path}"
    backup_dest_archive_path="${backup_dest_path%/}/${archive_filename}"
    pre_exec
    ssh ${backup_dest_ssh_opts}${backup_dest_uri} -T "mkdir -p ${backup_dest_path}"
    # backup remote source to remote dest
    ssh ${backup_src_ssh_opts}${backup_src_uri} "tar -c -C ${backup_src_path} ${exclude_resource_str}${backup_resource_str} | {{!archive_command}}"\
    | ssh ${backup_dest_ssh_opts}${backup_dest_uri} -T "cat > ${backup_dest_archive_path}"
    post_exec

    chown_remote "${backup_dest_ssh_opts}${backup_dest_uri}" "${backup_dest_archive_path}"
    chmod_remote "${backup_dest_ssh_opts}${backup_dest_uri}" "${backup_dest_archive_path}"
    link_latest_remote "${backup_dest_ssh_opts}${backup_dest_uri}" "${backup_dest_archive_path}"
    clean_older_than_remote "${backup_dest_ssh_opts}${backup_dest_uri}" "${backup_dest_archive_path}" "${archive_matchname}"

  else

    backup_dest_archive_path="${backup_dest%/}/${archive_filename}"
    pre_exec
    # backup remote source to local dest..
    ssh ${backup_src_ssh_opts}${backup_src_uri} "tar -c -C ${backup_src_path} ${exclude_resource_str}${backup_resource_str} | {{!archive_command}}"\
    | cat > ${backup_dest_archive_path}
    post_exec

    chown_local ${backup_dest_archive_path}
    chmod_local ${backup_dest_archive_path}
    link_latest_local ${backup_dest_archive_path}
    clean_older_than_local ${backup_dest_archive_path} ${archive_matchname}

  fi

# the backup source is local..
else

  # if the backup destination is remote..
  if [[ "$backup_dest" == "${ssh_prefix}"* ]]; then

    parse_url "$backup_dest"
    backup_dest_uri="${user}@${host}"
    if [[ "$port" != "" ]]; then
      backup_dest_ssh_opts="-p ${port} ${backup_dest_ssh_opts}"
    fi
    backup_dest_path="${path}"
    backup_dest_archive_path="${backup_dest_path%/}/${archive_filename}"
    pre_exec
    # backup local source to remote dest
    ssh ${backup_dest_ssh_opts}${backup_dest_uri} -T "mkdir -p ${backup_dest_path}"
    tar -c -C ${backup_src} ${exclude_resource_str}${backup_resource_str}\
    | {{!archive_command}}\
    | ssh ${backup_dest_ssh_opts}${backup_dest_uri} -T "cat > ${backup_dest_archive_path}"
    post_exec

    chown_remote "${backup_dest_ssh_opts}${backup_dest_uri}" "${backup_dest_archive_path}"
    chmod_remote "${backup_dest_ssh_opts}${backup_dest_uri}" "${backup_dest_archive_path}"
    link_latest_remote "${backup_dest_ssh_opts}${backup_dest_uri}" "${backup_dest_archive_path}"
    clean_older_than_remote "${backup_dest_ssh_opts}${backup_dest_uri}" "${backup_dest_archive_path}" "${archive_matchname}"

  else

    backup_dest_archive_path="${backup_dest%/}/${archive_filename}"
    pre_exec
    # backup local source to local dest
    tar -c -C ${backup_src} ${exclude_resource_str}${backup_resource_str}\
    | {{!archive_command}}\
    | cat > ${backup_dest_archive_path}
    post_exec

    chown_local ${backup_dest_archive_path}
    chmod_local ${backup_dest_archive_path}
    link_latest_local ${backup_dest_archive_path}
    clean_older_than_local ${backup_dest_archive_path} ${archive_matchname}

  fi

fi

if [[ "$quiet" != true ]]; then
  finish_time=`date`
  printf "Finished Run: ${finish_time}\n"
  echo "$0 run complete."
fi

exit 0;
