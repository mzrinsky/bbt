#!/usr/bin/env bash

# BBT Bash Backup Script
# This script is generated by the Better Backup Tool,
# and is used to create backup snapshots.

# TODO: Before release..
# cleanup comments..
# mention that it's limited by the max number of command line arguments..
# see how hard it would be to put it behind a flag..
# remove the script signature stuff, because it just does not serve a purpose?

shopt -s extglob

# the resources we want to backup
declare -a backup_resources=(
{{!backup_resources}}
)

# resources which should be excluded from backups
declare -a backup_exclude_resources=(
{{!backup_exclude_resources}}
)

backup_src="{{!backup_src}}"
backup_dest="{{!backup_dest}}"
backup_src_ssh_opts="{{!backup_src_ssh_opts}}"
backup_dest_ssh_opts="{{!backup_dest_ssh_opts}}"
archive_basename="{{!archive_base_name}}"
link_latest="{{!archive_link_latest}}"
ch_archive_owner="{{!archive_owner}}"
ch_archive_perms="{{!archive_perms}}"
archive_keep_days={{!archive_keep_days}}
quiet=false
script_signature="{{!script_signature}}"

while [ $# -gt 0 ]; do
  case "$1" in
    -q|--quiet)
      quiet=true
      ;;
    -bs=*|--backup-src=*)
      backup_src="${1#*=}"
      ;;
    -sso=*|--src-ssh-opts=*)
      backup_src_ssh_opts="${1#*=}"
      ;;
    -bd|--backup-dest=*)
      backup_dest="${1#*=}"
      ;;
    -dso=*|--dest-ssh-opts=*)
      backup_dest_ssh_opts="${1#*=}"
      ;;
    -abn=*|--archive-base-name=*)
      archive_basename="${1#*=}"
      ;;
    *)
      printf "Unknown or invalid command line argument : $1 \n"
      printf "Arguments are in the form -s -s=value or --long --long=value"
      exit 1
  esac
  shift
done

# parse_url "ssh://user@host:9090/this/is/the.path"
# echo "Potocol:"$proto" User:"$usr" Host:"$host" Port:"$port" Path:"$path
function parse_url() {
  local url=$1

  tmp=${url#*//};user=${tmp%@*}
  tmp=${url#*@};host=${tmp%%/*};[[ ${url#*://} == *":"* ]] && host=${host%:*}
  tmp=${url#*//};path=/${tmp#*/}
  proto=${url%%:*}
  [[ ${url#*://} == *":"* ]] && tmp=${url##*:} && port=${tmp%%/*}
  echo "parse_url Proto:"$proto", User:"$user", Host:"$host", Port:"$port", Path:"$path
}

function join_by {
  local d="${1-}" f="${2-}"
  if shift 2; then
    printf "%s" "$f" "${@/#/$d}"
  fi
}

function printerr() {
  printf "%s\n" "$*" >&2
}

function chown_remote() {
  local remote_str="$1"
  local remote_file="$2"
  if [[ "${ch_archive_owner}" != "" ]]; then
    if [[ "$quiet" != true ]]; then
      echo "Changing ownership to ${ch_archive_owner} on ${remote_str} ${remote_file}"
    fi
    set -ex
    ssh ${remote_str} "chown ${ch_archive_owner} ${remote_file}"
    set +ex
  fi
}

function chmod_remote() {
  local remote_str="$1"
  local remote_file="$2"
  if [[ "${ch_archive_perms}" != "" ]]; then
    if [[ "$quiet" != true ]]; then
      echo "Changing permissions to ${ch_archive_perms} on ${remote_str} ${remote_file}"
    fi
    set -ex
    ssh ${remote_str} "chmod ${ch_archive_perms} ${remote_file}"
    set +ex
  fi
}

function link_latest_remote() {
  local remote_str="$1"
  local remote_file="$2"
  local remote_link="${remote_file%\/*}/latest"
  local remote_target_filename=${remote_file##*\/}
  local remote_target_path=${remote_file%\/*}

  if [[ "${link_latest}" == true ]]; then
    if [[ "$quiet" != true ]]; then
      echo "Linking ${remote_str} ${remote_file} => ${remote_link}"
    fi
    set -ex
    ssh ${remote_str} "cd ${remote_target_path} && ln -sf ${remote_target_filename} latest"
    set +ex
  fi
}

function clean_older_than_remote() {
  local remote_str="$1"
  local remote_file="$2"
  local remote_path="${remote_file%\/*}"
  if [[ "${archive_keep_days}" -gt 0 ]]; then
    if [[ "$quiet" != true ]]; then
      echo "Cleaning files older than ${archive_keep_days} days from ${remote_str} ${remote_path} .."
    fi
    set -ex
    ssh ${remote_str} "find ${remote_path} -mtime +${archive_keep_days} -print -delete"
    set +ex
  fi
}

function chmod_local() {
  local local_file="$1"
  if [[ "${ch_archive_perms}" != "" ]]; then
    if [[ "$quiet" != true ]]; then
      echo "Changing permissions to ${ch_archive_perms} on ${local_file}"
    fi
    set -ex
    chmod ${ch_archive_perms} ${local_file}
    set +ex
  fi
}

function chown_local() {
  local local_file="$1"
  if [[ "${ch_archive_owner}" != "" ]]; then
    if [[ "$quiet" != true ]]; then
      echo "Changing ownership to ${ch_archive_owner} on ${local_file}"
    fi
    set -ex
    chown ${ch_archive_owner} ${local_file}
    set +ex
  fi
}

function link_latest_local() {
  local local_file="$1"
  local target_filename="${local_file##*\/}"
  local target_path="${local_file%\/*}"
  local local_link="${local_file%\/*}/latest"

  if [[ "${link_latest}" == true ]]; then
    if [[ -e $local_link || -L $local_link ]]; then
      if [[ ! -L $local_link ]]; then
        printerr "latest already exists but is not a symlink, exiting - ${local_link}"
        exit 1;
      else
        # this seems redundant, but ln will still error even with -f,
        # if the new link points to the same file as the old one.
        # instead of detecting that condition, its easier to just remove the link.
        rm ${local_link}
      fi
    fi
    if [[ "$quiet" != true ]]; then
      echo "Linking ${local_link} => ${local_file}"
    fi
    set -ex
    # ln has an easier time if you just cd to the dir where you want the link..
    # then it is easy to make the relative link.
    local cdir=`pwd`
    cd "${target_path}" && ln -sf "${target_filename}" "latest" && cd "${cdir}"
    set +ex
  fi
}

function clean_older_than_local() {
  local local_file="$1"
  local local_path="${local_file%\/*}"
  if [[ "${archive_keep_days}" -gt 0 ]]; then
    if [[ "$quiet" != true ]]; then
      echo "Cleaning files older than ${archive_keep_days} days from ${local_path} .."
    fi
    # find is a snowflake, and needs to be a in a writeable dir or else it complains..
    local cdir=`pwd`
    set -ex
    cd /tmp && find ${local_path} -mtime +${archive_keep_days} -print -delete && cd ${cdir}
    set +ex
  fi
}

# TODO: This whole backup / exclude section, should be dynamic and based on the number of resources..
#       there should be some sort of limit which triggers using temp files instead of cmd args.
#       ir could always use tmp files, but that seems lazy..
# we replace any leading / with ./ because that is what tar expects.
# this is intentional, this is the kind of detail BBT makes easier.
# just put filenames in the array, and let BBT do the right thing.
backup_resource_str=`join_by " " ${backup_resources[@]/#\//.\/}`
# exclude resource names need to match the resource name, so we also replace the leading / with ./
exclude_resource_str=`join_by " --exclude " "${backup_exclude_resources[@]/#\//.\/}"`
if [[ "${exclude_resource_str}" != "" ]]; then
  exclude_resource_str="--anchored --exclude ${exclude_resource_str} "
fi


if [[ "$quiet" != true ]]; then
  start_time=`date`
  printf "$0 run started.\nStart Time: ${start_time}\n"
fi

# this is dumb, and we should just generate the uuid at the time we process the template.
sig_uuid=`uuidgen -s -n '@x500' -N "${script_signature}"`
if [[ "$quiet" != true ]]; then
  printf "Script uuid: ${sig_uuid}\n"
fi

archive_datetime=`date "+%F-%H_%M_%S"`
archive_filename="${archive_basename}-${archive_datetime}.tar.gz"


ssh_prefix="ssh://"

if [[ "$quiet" != true ]]; then
  echo "Trying backup src: ${backup_src}, dest: ${backup_dest}"
fi

# if the backup source is remote..
if [[ "$backup_src" == "${ssh_prefix}"* ]]; then

  parse_url "$backup_src"
  backup_src_uri="ssh://${user}@${host}"
  if [[ "$port" != "" ]]; then
    backup_src_uri="${backup_src_uri}:${port}"
  fi
  backup_src_path="${path}"

  # if the backup destination is remote..
  if [[ "$backup_dest" == "${ssh_prefix}"* ]]; then

    parse_url "$backup_dest"
    backup_dest_uri="ssh://${user}@${host}"
    if [[ "$port" != "" ]]; then
      backup_dest_uri="${backup_dest_uri}:${port}"
    fi
    backup_dest_path="${path}"
    set -ex
    # backup remote source to remote dest
    ssh ${backup_src_ssh_opts}${backup_src_uri} "tar -c -C / ${exclude_resource_str}${backup_resource_str} | {{!archive_command}}"\
    | ssh ${backup_dest_ssh_opts}${backup_dest_uri} -T "cat > ${backup_dest_archive_path}"
    set +ex

    chown_remote "${backup_dest_ssh_opts}${backup_dest_uri}" "${backup_dest_archive_path}"
    chmod_remote "${backup_dest_ssh_opts}${backup_dest_uri}" "${backup_dest_archive_path}"
    link_latest_remote "${backup_dest_ssh_opts}${backup_dest_uri}" "${backup_dest_archive_path}"
    clean_older_than_remote "${backup_dest_ssh_opts}${backup_dest_uri}" "${backup_dest_archive_path}"

  else

    backup_dest_archive_path="${backup_dest%/}/${archive_filename}"
    set -ex
    # backup remote source to local dest..
    ssh ${backup_src_ssh_opts}${backup_src_uri} "tar -c -C / ${exclude_resource_str}${backup_resource_str} | {{!archive_command}}"\
    | cat > ${backup_dest_archive_path}
    set +ex

    chown_local ${backup_dest_archive_path}
    chmod_local ${backup_dest_archive_path}
    link_latest_local ${backup_dest_archive_path}
    clean_older_than_local ${backup_dest_archive_path}

  fi

# the backup source is local..
else

  # if the backup destination is remote..
  if [[ "$backup_dest" == "${ssh_prefix}"* ]]; then

    parse_url "$backup_dest"
    backup_dest_uri="ssh://${user}@${host}"
    if [[ "$port" != "" ]]; then
      backup_dest_uri="${backup_dest_uri}:${port}"
    fi
    backup_dest_path="${path}"
    backup_dest_archive_path="${backup_dest_path}/${archive_filename}"
    set -ex
    # backup local source to remote dest
    tar -c -C / ${exclude_resource_str}${backup_resource_str}\
    | {{!archive_command}}\
    | ssh ${backup_dest_ssh_opts}${backup_dest_uri} -T "cat > ${backup_dest_archive_path}"
    set +ex

    chown_remote "${backup_dest_ssh_opts}${backup_dest_uri}" "${backup_dest_archive_path}"
    chmod_remote "${backup_dest_ssh_opts}${backup_dest_uri}" "${backup_dest_archive_path}"
    link_latest_remote "${backup_dest_ssh_opts}${backup_dest_uri}" "${backup_dest_archive_path}"
    clean_older_than_remote "${backup_dest_ssh_opts}${backup_dest_uri}" "${backup_dest_archive_path}"

  else

    backup_dest_archive_path="${backup_dest%/}/${archive_filename}"
    set -ex
    # backup local source to local dest
    tar -c -C / ${exclude_resource_str}${backup_resource_str}\
    | {{!archive_command}}\
    | cat > ${backup_dest_archive_path}
    set +ex

    chown_local ${backup_dest_archive_path}
    chmod_local ${backup_dest_archive_path}
    link_latest_local ${backup_dest_archive_path}
    clean_older_than_local ${backup_dest_archive_path}

  fi

fi

if [[ "$quiet" != true ]]; then
  echo "Script Signature: ${script_signature}"
  sys_str=`uname -a`
  finish_time=`date`
  printf "System: ${sys_str}\nFinished Run: ${finish_time}\n"
  echo "$0 run complete."
fi

exit 0;

# the file list needs to get written out to a tmp file.
# for a remote backup....
# we can run tar -cf - --verbatim-files-from --files-from tmpfile.txt | pigz --fast | ssh remote-backup@m33x7 "cat > /backup/location.tar.gz"
# for a local backup we can run tar -cf - --verbatim-files-from --files-from tmpfile.txt | pigz --fast | cat > /backup/location.tar.gz
