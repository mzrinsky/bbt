#!/usr/bin/env bash

# BBT Bash Restore Script
# This script is generated by the Better Backup Tool,
# and is used to restore backup snapshots created by bbt.

# TODO: Before Release..
# cleanup comments..
# remove script signature.. - done
# fix argument length issue same as backup script.

# the resources that should be restored from the snapshot
declare -a restore_resources=(
{{!restore_resources}}
)

# resources that should be excluded when restoring
declare -a restore_exclude_resources=(
{{!restore_exclude_resources}}
)

restore_src="{{!restore_src}}"
restore_dest="{{!restore_dest}}"
restore_src_ssh_opts="{{!restore_src_ssh_opts}}"
restore_dest_ssh_opts="{{!restore_dest_ssh_opts}}"
quiet=false


while [ $# -gt 0 ]; do
  case "$1" in
    -q|--quiet)
      quiet=true
      ;;
    -rs=*|--restore-src=*)
      restore_src="${1#*=}"
      ;;
    -sso=*|--src-ssh-opts=*)
      restore_src_ssh_opts="${1#*=}"
      ;;
    -rd|--restore-dest=*)
      restore_dest="${1#*=}"
      ;;
    -dso=*|--dest-ssh-opts=*)
      restore_dest_ssh_opts="${1#*=}"
      ;;
    -h|--help)
      printf "BBT Restore Help. \n"
      printf "Available Command Arguments: \n"
      printf "\t-q --quiet : Do NOT print status to stdout\n"
      printf "\t-rs= --restore-src= : The source archive to restore from. (local path or ssh://user@host/path)\n"
      printf "\t-rd= --restore-dest= : The destination to restore to. (local path or ssh://user@host/path)\n"
      exit 0
      ;;
    *)
      printf "Unknown or invalid command line argument : $1 \n"
      printf "Arguments are in the form -s -s=value or --long --long=value\n"
      printf "Use -h or --help for a full list of arguments"
      exit 1
  esac
  shift
done

function printerr() {
  printf "%s\n" "$*" >&2
}

if [[ "$quiet" != true ]]; then
  start_time=`date`
  printf "$0 run started.\nStart Time: ${start_time}\n"
fi

function join_by {
  local d=${1-} f=${2-}
  if shift 2; then
    printf %s "$f" "${@/#/$d}"
  fi
}

# parse_url "ssh://user@host:9090/this/is/the.path"
# echo "Potocol:"$proto" User:"$usr" Host:"$host" Port:"$port" Path:"$path
function parse_url() {
  local url=$1

  tmp=${url#*//};user=${tmp%@*}
  tmp=${url#*@};host=${tmp%%/*};[[ ${url#*://} == *":"* ]] && host=${host%:*}
  tmp=${url#*//};path=/${tmp#*/}
  proto=${url%%:*}
  [[ ${url#*://} == *":"* ]] && tmp=${url##*:} && port=${tmp%%/*}
  echo "parse_url Proto:"$proto", User:"$user", Host:"$host", Port:"$port", Path:"$path
}

restore_resource_str=`join_by " " ${restore_resources[@]/#\//.\/}`
exclude_resource_str=`join_by " --exclude " ${restore_exclude_resources[@]/#\//.\/}`
if [[ "${exclude_resource_str}" != "" ]]; then
  exclude_resource_str="--anchored --exclude ${exclude_resource_str} "
fi

function restore() {
  local r_from=$1
  local r_items=$2
  if [[ "$quiet" != true ]]; then
    echo "Restoring resources ${r_items} from ${r_from} into ${restore_dest} excluding ${exclude_resource_str}"
  fi
  set -e
  tar -C "${restore_dest}" --overwrite -xzvf "${r_from}" ${r_items}
  set +e
}

function restore_from_remote() {
  local r_from=$1
  local r_host=$2
  local r_items=$3
  if [[ "$quiet" != true ]]; then
    echo "Restoring resources ${r_items} from remote host ${r_host} archive ${r_from} into ${restore_dest} excluding ${exclude_resource_str}"
  fi
  set -e
  ssh ${remote_restore_opts}${remote_restore_host} "cat ${remote_restore_src}"\
  | tar -C "${restore_dest}" --overwrite -xzvf - ${exclude_resource_str}${r_items}
  set +e
}

ssh_prefix="ssh://"

function try_restore() {

  if [[ "$quiet" != true ]]; then
    echo "Trying restore src: ${restore_src}, dest: ${restore_dest}"
  fi

  # if the restore source is remote..
  if [[ "$restore_src" == "${ssh_prefix}"* ]]; then

    # parse_url "ssh://user@host:9090/this/is/the.path"
    # echo "Potocol:"$proto" User:"$usr" Host:"$host" Port:"$port" Path:"$path
    # parse the url, so we can get the path etc.
    parse_url "$restore_src"
    restore_src_uri="ssh://${user}@${host}"
    if [[ "$port" != "" ]]; then
      restore_src_uri="${restore_src_uri}:${port}"
    fi
    restore_src_path="${path}"


    # if the restore dest is also remote (remote src => remote dest)
    if [[ "$restore_dest" == "${ssh_prefix}"* ]]; then

      # restore from remote src, to remote dest
      # parse the url, so we can get the path etc.
      parse_url "$restore_dest"
      restore_dest_uri="ssh://${user}@${host}"
      if [[ "$port" != "" ]]; then
        restore_dest_uri="${restore_dest_uri}:${port}"
      fi
      restore_dest_path="${path}"

      set -exo pipefail
      ssh ${restore_src_ssh_opts}${restore_src_uri} "cat ${restore_src_path}" \
      | ssh ${restore_dest_ssh_opts}${restore_dest_uri} \
      " tar -C ${restore_dest_path} --overwrite -xzvf - ${exclude_resource_str}${restore_resource_str}"
      set +exo pipefail

    # else the restore dest is local (remote src => local dest)
    else

      set -exo pipefail
      # restore from remote src, to local dest
      ssh ${restore_src_ssh_opts}${restore_src_uri} "cat ${restore_src_path}" \
      | tar -C ${restore_dest} --overwrite -xzvf - ${exclude_resource_str}${restore_resource_str}
      set +exo pipefail

    fi

  # else the restore src is local
  else

    # if the restore dest is remote.. (local src => remote dest)
    if [[ "$restore_dest" == "${ssh_prefix}"* ]]; then

      # restore from remote src, to remote dest
      # parse the url, so we can get the path etc.
      parse_url "$restore_dest"
      restore_dest_uri="ssh://${user}@${host}"
      if [[ "$port" != "" ]]; then
        restore_dest_uri="${restore_dest_uri}:${port}"
      fi
      restore_dest_path="${path}"

      # restore from local src, to remote dest
      set -exo pipefail
      cat ${restore_src_path} \
      | ssh ${restore_dest_ssh_opts}${restore_dest_uri} \
      "tar -C ${restore_dest_path} --overwrite -xzvf - ${exclude_resource_str}${restore_resource_str}"
      set +exo pipefail

    # else the restore dest is local.. (local src => local dest)
    else
      # restore from local src, to local dest
      set -exo pipefail
      tar -C ${restore_dest} --overwrite -xzvf ${restore_src} ${exclude_resource_str}${restore_resource_str}
      set +exo pipefail
    fi

  fi
}

try_restore

if [[ "$quiet" != true ]]; then
  sys_str=`uname -a`
  finish_time=`date`
  printf "System: ${sys_str}\nFinished Run: ${finish_time}\n"
  echo "$0 run complete."
fi

exit 0;
